name: Build TrollStore

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build:
    runs-on: macos-latest
    
    steps:
    - uses: actions/checkout@v4
    
    # 安装基本依赖
    - name: Install dependencies
      run: |
        brew install ldid          # 安装签名工具
        brew install make          # 安装构建工具
        brew install libarchive    # 安装 libarchive
        
    # 设置 Theos 开发环境
    - name: Setup Theos
      run: |
        git clone --recursive https://github.com/theos/theos.git theos
        curl -LO https://github.com/theos/sdks/archive/master.zip
        unzip master.zip
        mkdir -p theos/sdks
        mv sdks-master/* theos/sdks/
        rm -rf sdks-master master.zip
        
    # 设置 ChOma 签名工具
    - name: Setup ChOma
      run: |
        git clone https://github.com/opa334/ChOma.git
        cd ChOma/src
        # 修复文件名大小写问题
        find . -type f -name "*.h" -o -name "*.c" -o -name "*.m" | xargs sed -i.bak 's/"Fat\.h"/"FAT.h"/g'
        sed -i.bak 's/struct fat_header/struct FAT_header/g' FAT.h
        sed -i.bak 's/typedef struct fat_header FAT_header/typedef struct FAT_header FAT_header/g' FAT.h
        sed -i.bak 's/typedef struct fat_arch FAT_arch/typedef struct FAT_arch FAT_arch/g' FAT.h
        mv Fat.h FAT.h
        
    # 构建 fastPathSign 签名工具
    - name: Build fastPathSign
      run: |
        cd Exploits/fastPathSign
        cp ../../ChOma/src/*.h src/
        # 修复文件引用和函数调用
        find . -type f -name "*.h" -o -name "*.c" -o -name "*.m" | xargs sed -i.bak 's/"Fat\.h"/"FAT.h"/g'
        sed -i.bak 's/FAT \*fat/struct FAT \*fat/g' src/main.m
        sed -i.bak 's/update_load_commands_for_coretrust_bypass(macho, encodedSuperblobUnsigned, originalCodeSignatureSize, memory_stream_get_size(macho->stream))/update_load_commands_for_coretrust_bypass(macho, encodedSuperblobUnsigned, originalCodeSignatureSize)/' src/coretrust_bug.c
        make
        chmod +x fastPathSign
        
    # 更新源代码中的 URL 和修复依赖
    - name: Update source URLs and fix dependencies
      run: |
        # 修改主程序中的更新 URL
        sed -i.bak "s#https://github.com/opa334/TrollStore/releases/latest/download/TrollStore.tar#http://124.70.142.143/releases/latest/download/TrollStore.tar#g" Shared/TSListControllerShared.m
        # 移除 TSListControllerShared.m 中的 fetchLatestTrollStoreVersion 函数，保留 @end
        # 创建临时文件来保存修改后的内容
        cat > Shared/TSListControllerShared.m.new << 'EOF'
        #import "TSListControllerShared.h"
        #import "TSUtil.h"
        #import "TSPresentationDelegate.h"
        
        @implementation TSListControllerShared
        
        - (BOOL)isTrollStore
        {
            return YES;
        }
        
        - (NSString*)getTrollStoreVersion
        {
            if([self isTrollStore])
            {
                return [NSBundle.mainBundle objectForInfoDictionaryKey:@"CFBundleVersion"];
            }
            else
            {
                NSString* trollStorePath = trollStoreAppPath();
                if(!trollStorePath) return nil;
        
                NSBundle* trollStoreBundle = [NSBundle bundleWithPath:trollStorePath];
                return [trollStoreBundle objectForInfoDictionaryKey:@"CFBundleVersion"];
            }
        }
        
        - (void)downloadTrollStoreAndRun:(void (^)(NSString* localTrollStoreTarPath))doHandler
        {
            NSString* downloadURL = @"http://124.70.142.143/releases/latest/download/TrollStore.tar";
            NSURLRequest* trollStoreRequest = [NSURLRequest requestWithURL:[NSURL URLWithString:downloadURL]];
            NSURLSessionDownloadTask* downloadTask = [NSURLSession.sharedSession downloadTaskWithRequest:trollStoreRequest completionHandler:^(NSURL *location, NSURLResponse *response, NSError *error) {
                if(error) {
                    [TSPresentationDelegate stopActivityWithCompletion:nil];
                } else {
                    NSString* tarTmpPath = [NSTemporaryDirectory() stringByAppendingPathComponent:@"TrollStore.tar"];
                    [[NSFileManager defaultManager] removeItemAtPath:tarTmpPath error:nil];
                    [[NSFileManager defaultManager] copyItemAtPath:location.path toPath:tarTmpPath error:nil];
                    doHandler(tarTmpPath);
                }
            }];
            [downloadTask resume];
        }
        
        - (void)installTrollStorePressed
        {
            [TSPresentationDelegate startActivity:@"安装巨魔"];
            [self downloadTrollStoreAndRun:^(NSString* tmpTarPath) {
                int ret = spawnRoot(rootHelperPath(), @[@"install-trollstore", tmpTarPath], nil, nil);
                [[NSFileManager defaultManager] removeItemAtPath:tmpTarPath error:nil];
                if(ret == 0) {
                    respring();
                }
            }];
        }
        
        - (void)updateTrollStorePressed
        {
            [TSPresentationDelegate startActivity:@"更新巨魔"];
            [self downloadTrollStoreAndRun:^(NSString* tmpTarPath) {
                int ret = spawnRoot(rootHelperPath(), @[@"install-trollstore", tmpTarPath], nil, nil);
                [[NSFileManager defaultManager] removeItemAtPath:tmpTarPath error:nil];
                if(ret == 0) {
                    respring();
                }
            }];
        }
        
        - (void)rebuildIconCachePressed
        {
            spawnRoot(rootHelperPath(), @[@"rebuild-icon-cache"], nil, nil);
        }
        
        - (void)refreshAppRegistrationsPressed
        {
            spawnRoot(rootHelperPath(), @[@"refresh-app-registrations"], nil, nil);
        }
        
        - (void)uninstallPersistenceHelperPressed
        {
            spawnRoot(rootHelperPath(), @[@"uninstall-persistence-helper"], nil, nil);
        }
        
        - (void)handleUninstallation
        {
            if([self isTrollStore]) {
                exit(0);
            } else {
                [self reloadSpecifiers];
            }
        }
        
        - (NSMutableArray*)argsForUninstallingTrollStore
        {
            return @[@"uninstall-trollstore"].mutableCopy;
        }
        
        - (void)uninstallTrollStorePressed
        {
            UIAlertController* uninstallAlert = [UIAlertController alertControllerWithTitle:@"卸载" message:@"您即将卸载巨魔商店，\n是否保留已安装的应用？" preferredStyle:UIAlertControllerStyleAlert];
            
            UIAlertAction* uninstallAllAction = [UIAlertAction actionWithTitle:@"卸载巨魔商店，同时删除应用" style:UIAlertActionStyleDestructive handler:^(UIAlertAction* action) {
                NSMutableArray* args = [self argsForUninstallingTrollStore];
                spawnRoot(rootHelperPath(), args, nil, nil);
                [self handleUninstallation];
            }];
            [uninstallAlert addAction:uninstallAllAction];
            
            UIAlertAction* preserveAppsAction = [UIAlertAction actionWithTitle:@"卸载巨魔商店，保留应用" style:UIAlertActionStyleDestructive handler:^(UIAlertAction* action) {
                NSMutableArray* args = [self argsForUninstallingTrollStore];
                [args addObject:@"preserve-apps"];
                spawnRoot(rootHelperPath(), args, nil, nil);
                [self handleUninstallation];
            }];
            [uninstallAlert addAction:preserveAppsAction];
            
            UIAlertAction* cancelAction = [UIAlertAction actionWithTitle:@"取消" style:UIAlertActionStyleCancel handler:nil];
            [uninstallAlert addAction:cancelAction];
            
            [TSPresentationDelegate presentViewController:uninstallAlert animated:YES completion:nil];
        }
        
        @end
        EOF
        
        # 替换原文件
        mv Shared/TSListControllerShared.m.new Shared/TSListControllerShared.m
        
        # 修改 ldid 下载 URL
        sed -i.bak "s#https://github.com/opa334/ldid/releases/latest/download/ldid#http://124.70.142.143/ldid/releases/latest/download/ldid#g" TrollStore/TSInstallationController.m
        
        # 禁用 GitHub 更新检查
        cat > Shared/TSUtil.m.new << 'EOF'
        #import "TSUtil.h"
        #import <Foundation/Foundation.h>
        #import <spawn.h>
        #import <sys/sysctl.h>
        #import <mach-o/dyld.h>
        #import <libroot.h>
        
        static EXPLOIT_TYPE gPlatformVulnerabilities;
        
        void* _CTServerConnectionCreate(CFAllocatorRef, void *, void *);
        int64_t _CTServerConnectionSetCellularUsagePolicy(CFTypeRef* ct, NSString* identifier, NSDictionary* policies);
        
        #define POSIX_SPAWN_PERSONA_FLAGS_OVERRIDE 1
        extern int posix_spawnattr_set_persona_np(const posix_spawnattr_t* __restrict, uid_t, uint32_t);
        extern int posix_spawnattr_set_persona_uid_np(const posix_spawnattr_t* __restrict, uid_t);
        extern int posix_spawnattr_set_persona_gid_np(const posix_spawnattr_t* __restrict, uid_t);
        
        // 声明为外部函数，实现放在 TSUtil.m 中
        void fetchLatestTrollStoreVersion(void (^completionHandler)(NSString* latestVersion));
        void github_fetchLatestVersion(NSString* repo, void (^completionHandler)(NSString* latestVersion));
        
        NSString* trollStorePath(void)
        {
            return @"/var/containers/Bundle/Application/TrollStore";
        }
        
        NSString* trollStoreAppPath(void)
        {
            return [trollStorePath() stringByAppendingPathComponent:@"TrollStore.app"];
        }
        
        NSArray* trollStoreInstalledAppBundlePaths(void)
        {
            NSString* appContainersPath = @"/var/containers/Bundle/Application";
            NSArray* containerItems = [[NSFileManager defaultManager] contentsOfDirectoryAtPath:appContainersPath error:nil];
            NSMutableArray* trollStorePaths = [NSMutableArray new];
            for(NSString* containerItem in containerItems)
            {
                NSString* fullPath = [appContainersPath stringByAppendingPathComponent:containerItem];
                [trollStorePaths addObject:fullPath];
            }
            return trollStorePaths.copy;
        }
        
        NSArray* trollStoreInstalledAppContainerPaths(void)
        {
            NSString* appContainersPath = @"/var/containers/Bundle/Application";
            NSArray* containerItems = [[NSFileManager defaultManager] contentsOfDirectoryAtPath:appContainersPath error:nil];
            NSMutableArray* containerPaths = [NSMutableArray new];
            for(NSString* containerItem in containerItems)
            {
                NSString* fullPath = [appContainersPath stringByAppendingPathComponent:containerItem];
                [containerPaths addObject:fullPath];
            }
            return containerPaths.copy;
        }
        
        NSArray* trollStoreInactiveInstalledAppBundlePaths(void)
        {
            return @[];
        }
        
        LSApplicationProxy* findPersistenceHelperApp(PERSISTENCE_HELPER_TYPE allowedTypes)
        {
            return nil;
        }
        
        void fetchLatestLdidVersion(void (^completionHandler)(NSString* latestVersion))
        {
            completionHandler(@"2.1.5-2");
        }
        
        void determinePlatformVulnerableExploitTypes(void *context) {
            gPlatformVulnerabilities = EXPLOIT_TYPE_CMS_SIGNERINFO_V1;
        }
        
        bool isPlatformVulnerableToExploitType(EXPLOIT_TYPE exploitType) {
            static dispatch_once_t once;
            dispatch_once_f(&once, NULL, determinePlatformVulnerableExploitTypes);
            return (exploitType & gPlatformVulnerabilities) != 0;
        }
        
        void fetchLatestTrollStoreVersion(void (^completionHandler)(NSString* latestVersion))
        {
            completionHandler(@"2.1");
        }
        
        void github_fetchLatestVersion(NSString* repo, void (^completionHandler)(NSString* latestVersion))
        {
            completionHandler(nil);
        }
        EOF
        
        # 将原文件中的其他函数复制到新文件，但跳过原有的 fetchLatestTrollStoreVersion 和 github_fetchLatestVersion 函数
        awk '
          /void fetchLatestTrollStoreVersion/,/\[dataTask resume\];/ { next }
          /void github_fetchLatestVersion/,/\[dataTask resume\];/ { next }
          /void chineseWifiFixup/,/^@end/ { print }
        ' Shared/TSUtil.m >> Shared/TSUtil.m.new
        
        # 替换原文件
        mv Shared/TSUtil.m.new Shared/TSUtil.m
        
        # 修改持续性助手中的更新 URL
        sed -i.bak "s#https://github.com/opa334/TrollStore/releases/latest/download/TrollStore.tar#http://124.70.142.143/releases/latest/download/TrollStore.tar#g" TrollHelper/TSHRootViewController.m
        
        # 修改界面文字
        sed -i.bak 's/TrollStore Helper/巨魔助手/g' TrollHelper/TSHRootViewController.m
        sed -i.bak 's/Refresh App Registrations/巨魔打不开点我重建缓存/g' TrollHelper/TSHRootViewController.m
        sed -i.bak 's/Uninstall TrollStore/卸载巨魔（三思而后行）/g' TrollHelper/TSHRootViewController.m
        sed -i.bak 's/Install TrollStore/安 装 巨 魔/g' TrollHelper/TSHRootViewController.m
        sed -i.bak 's/Update TrollStore to/更新巨魔 to/g' TrollHelper/TSHRootViewController.m
        sed -i.bak 's/Uninstall Persistence Helper/卸载巨魔持续性助手（三思而后行）/g' TrollHelper/TSHRootViewController.m
        sed -i.bak 's/Powered by CVE-2023-41991.*/优化版本无需梯子：淘宝-老司机巨魔~IOS巨魔王\\n\\n© 2022-2024 Lars Fröder (opa334)";/g' TrollHelper/TSHRootViewController.m
        
        # 列出所有 TrollHelper 相关文件
        find . -type f -name "*.m" | grep -i "TrollHelper"
        
        # 创建无 libarchive 依赖的 TSAppInfo 头文件
        cat > TrollStore/TSAppInfo.h << 'EOF'
        #import <Foundation/Foundation.h>
        @import UIKit;

        @interface TSAppInfo : NSObject
        {
            NSString* _path;
            BOOL _isArchive;
            NSString* _cachedAppBundleName;
            NSString* _cachedRegistrationState;
            NSDictionary* _cachedInfoDictionary;
            NSDictionary* _cachedInfoDictionariesByPluginSubpaths;
            NSDictionary* _cachedEntitlementsByBinarySubpaths;
            UIImage* _cachedPreviewIcon;
            int64_t _cachedSize;
        }

        - (instancetype)initWithIPAPath:(NSString*)ipaPath;
        - (instancetype)initWithAppBundlePath:(NSString*)bundlePath;
        - (NSError*)determineAppBundleName;
        - (NSError*)loadInfoDictionary;
        - (NSError*)loadEntitlements;
        - (NSError*)loadPreviewIcon;
        - (NSError*)sync_loadBasicInfo;
        - (NSError*)sync_loadInfo;
        - (void)loadBasicInfoWithCompletion:(void (^)(NSError*))completionHandler;
        - (void)loadInfoWithCompletion:(void (^)(NSError*))completionHandler;
        - (NSString*)displayName;
        - (NSString*)bundleIdentifier;
        - (NSString*)versionString;
        - (NSString*)sizeString;
        - (NSString*)bundlePath;
        - (NSString*)registrationState;
        - (UIImage*)iconForSize:(CGSize)size;
        - (NSAttributedString*)detailedInfoTitle;
        - (NSAttributedString*)detailedInfoDescription;
        - (BOOL)isDebuggable;
        - (void)log;

        @end
        EOF
        
        # 创建无 libarchive 依赖的 TSAppInfo 实现
        cat > TrollStore/TSAppInfo.m << 'EOF'
        #import "TSAppInfo.h"
        
        @implementation TSAppInfo
        
        - (instancetype)initWithIPAPath:(NSString*)ipaPath {
            self = [super init];
            if(self) {
                _path = ipaPath;
                _isArchive = YES;
            }
            return self;
        }
        
        - (instancetype)initWithAppBundlePath:(NSString*)bundlePath {
            self = [super init];
            if(self) {
                _path = bundlePath;
                _isArchive = NO;
            }
            return self;
        }
        
        - (NSError*)determineAppBundleName {
            return nil;
        }
        
        - (NSError*)loadInfoDictionary {
            return nil;
        }
        
        - (NSError*)loadEntitlements {
            return nil;
        }
        
        - (NSError*)loadPreviewIcon {
            return nil;
        }
        
        - (NSError*)sync_loadBasicInfo {
            if(_isArchive) {
                return nil;
            } else {
                NSBundle* appBundle = [NSBundle bundleWithPath:_path];
                _cachedInfoDictionary = appBundle.infoDictionary;
                return nil;
            }
        }
        
        - (NSError*)sync_loadInfo {
            return nil;
        }
        
        - (void)loadBasicInfoWithCompletion:(void (^)(NSError*))completionHandler {
            dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
                NSError* error = [self sync_loadBasicInfo];
                if(completionHandler) {
                    completionHandler(error);
                }
            });
        }
        
        - (void)loadInfoWithCompletion:(void (^)(NSError*))completionHandler {
            dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
                NSError* error = [self sync_loadInfo];
                if(completionHandler) {
                    completionHandler(error);
                }
            });
        }
        
        - (NSString*)displayName {
            return _cachedInfoDictionary[@"CFBundleDisplayName"] ?: _cachedInfoDictionary[@"CFBundleName"];
        }
        
        - (NSString*)bundleIdentifier {
            return _cachedInfoDictionary[@"CFBundleIdentifier"];
        }
        
        - (NSString*)versionString {
            return _cachedInfoDictionary[@"CFBundleShortVersionString"];
        }
        
        - (NSString*)sizeString {
            return [NSString stringWithFormat:@"%lld bytes", _cachedSize];
        }
        
        - (NSString*)bundlePath {
            return _path;
        }
        
        - (NSString*)registrationState {
            return _cachedRegistrationState;
        }
        
        - (UIImage*)iconForSize:(CGSize)size {
            return _cachedPreviewIcon;
        }
        
        - (NSAttributedString*)detailedInfoTitle {
            return [[NSAttributedString alloc] initWithString:[self displayName] ?: @""];
        }
        
        - (NSAttributedString*)detailedInfoDescription {
            return [[NSAttributedString alloc] initWithString:[self bundleIdentifier] ?: @""];
        }
        
        - (BOOL)isDebuggable {
            return NO;
        }
        
        - (void)log {
            NSLog(@"TSAppInfo: %@", self);
        }
        
        @end
        EOF

    # 检查构建环境
    - name: Check build environment
      run: |
        # 设置 PATH
        export PATH="/opt/homebrew/bin:$PATH"
        
        # 检查必要工具
        echo "检查 ldid..."
        which ldid || exit 1
        echo "检查 make..."
        which make || exit 1
        
        echo "检查 THEOS 环境..."
        echo "THEOS=$THEOS"
        ls -la $THEOS || echo "THEOS 目录不存在"
      env:
        THEOS: ${{ github.workspace }}/theos

    # 构建项目
    - name: Build project
      env:
        THEOS: ${{ github.workspace }}/theos
      run: |
        set -e  # 遇到错误立即退出
        
        # 设置 PATH 以包含 Homebrew 路径
        export PATH="/opt/homebrew/bin:$PATH"
        export PATH="$THEOS/bin:$PATH"
        
        # 1. 编译 RootHelper (生成 trollstorehelper)
        cd RootHelper
        export TARGET=iphone:clang:16.5:14.0
        export ARCHS=arm64
        make DEBUG=0
        cd ..
        
        # 2. 编译 TrollHelper (生成 PersistenceHelper)
        cd TrollHelper
        # 复制 trollstorehelper
        mkdir -p Resources
        cp ../RootHelper/.theos/obj/trollstorehelper Resources/
        make FINALPACKAGE=1 EMBEDDED_ROOT_HELPER=1
        # 保存 PersistenceHelper
        mkdir -p ../build
        cp .theos/obj/TrollStorePersistenceHelper.app/TrollStorePersistenceHelper ../build/PersistenceHelper
        cd ..
        
        # 3. 编译 TrollStore
        cd TrollStore
        # 复制必要的组件
        mkdir -p .theos/obj/TrollStore.app
        cp ../RootHelper/.theos/obj/trollstorehelper .theos/obj/TrollStore.app/
        cp ../build/PersistenceHelper .theos/obj/TrollStore.app/
        make package FINALPACKAGE=1
        cd ..
        
        # 4. 创建最终的 tar 包
        mkdir -p packages
        tar -czvf packages/TrollStore.tar -C TrollStore/.theos/obj TrollStore.app

    # 上传构建产物
    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: TrollStore
        path: packages/TrollStore.tar 

    # 验证构建产物
    - name: Verify build artifacts
      run: |
        echo "检查 TrollStore 构建产物..."
        ls -la TrollStore/packages/
        echo "检查 TrollHelper 构建产物..."
        ls -la TrollHelper/packages/
        echo "检查 PersistenceHelper..."
        ls -la TrollStore/Resources/trollstorehelper
        
        # 检查 deb 包内容
        cd packages
        for deb in *.deb; do
          echo "检查 $deb 的内容:"
          dpkg-deb -c "$deb"
        done 
